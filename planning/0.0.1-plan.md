# 0xbc01n

We are following the 80/20 rule in the below plan

## DATA BOUNTY APP

---

1. Data bounty backend that receives the api call to create the data bounty

- Python backend. No integration between React front and python backend, pure HTTP comms.
- Dockerfile for backend

1. Data bounty front-end. Most important requirements:

- **Log-in / sign up panel**. We need to let EVERYONE use this platform. This means make this website usable even for people who do not have metamask / hardware wallet. [I will explain this in more detail]
- **Create data bounty modal / page**. What meta goes here? Some that I can think of:

  - expiration
  - Types: a few (see extras). but to begin with: no approval required, anyone can start working on the bounty
  - price in OCEAN
  - Description of the bounty
  - creator of the bounty
  - date created

- **Data bounty page**. After Alice creates bounty this is its page
  bounty
- **Panel to search for bounties**. Do you think something similar to Gitcoin would be OK?

- **Sample data submission workflow**. I think that we would have a button on the data bounty page that allows Bob, Charlie and other freelancers to submit the sample of their dataset. No need for any meta other than the time when this was submitted, the id of the submitter, anything else? This will go into the db too. (sidenote on the db: looks like we don't need much relationships here, so it is better to go for non-relational db that would scale well in the future, e.g. MongoDB)

![gitcoins-bounty-explorer](assets/gitcoin-search.png)

---

### **EXTRAS: Pick the most important ones from below if we have time to do more**

Listed in the order of importance: top - most important

- Only the buyers of the dataset have the option to review the full dataset, and only after some while.
- More data bounty types:
  - A lot of people apply, you select one to work
  - Co-operative - everyone works on the single task. People express the interest in bounty, and then all get to work on the same task
  - Contest. Many teams work, you select one / multiple winners
  - linter for data
  - User Profile page
  - Help (tip and tricks, faq etc...)
  - [TheGraph, I think is is like GraphQL](https://thegraph.com/)

---

### Application routes map

- Welcome page (application overview (Log-in/sign up modal))
- All bounties (with filters panel)
- Bounty view page
- Bounty create page
- Bounty edit page

### Application backend (Python Falcon)

1. [POST] call to authenticate the user (?Dima: user presses login -> (a) they do not have an ethereum addres (b) they have ethereum address

(a) we make them create one, and go back to our app
(b) on successful log-in to metamask, we send a call to backend, containing the following:

{
"userEthAddr": 0xaa2212999b2321...,
? anything else (timestamp and unique id i'll make on the backend)
}

2. [GET] paginated all & partial (filtered bounties (with query params, like tags, creation date, number of applicants, etc.)) bounties request (to view all bounties). This just gives the "meta" info, like the icon of the bounty, timestamp of creation, etc. (like on gitcoin)

when no query params are passed (except for the default ones, for example the default number of paginated bounties) return all,
when query params are specified, meet them. so one endpoint for this

3. [PUT] create / edit bounty

{
"bounty name": "djfksajfklsj",
"funder": ethAddr,
"price": 200 OCEAN,
"expiry": unix int,
"bounty type": enum string,
?
}

^ if id is specified in the above, then that is the edit call. Disable the edit button on the front for non-funders

### DB Schemas

- User
- unique_id primary key (generate on the fly for now. 5 char base64 encoded string gives 1 billion combos and will only take 0.1 MB space)
- ethereum address
- date first joined

---
